import { BaseApiService } from '../core/BaseApiService';
import type { Repair, CreateRepairData } from './types';

export class RepairsApiService extends BaseApiService<Repair, CreateRepairData> {
  constructor() {
    super('repairs', `
      *,
      client:clients(id, type, first_name, last_name, company_name, email, phone),
      technician:profiles(id, username),
      repair_parts(
        id,
        product_id,
        quantity,
        unit_cost,
        total_cost,
        product:products(id, brand, model)
      )
    `);
  }

  async search(searchTerm: string): Promise<Repair[]> {
    if (!searchTerm) return this.getAll();
    
    console.log('Searching repairs with term:', searchTerm);
    
    const query = this.supabase
      .from(this.tableName as any)
      .select(this.selectQuery)
      .or(`repair_number.ilike.%${searchTerm}%,device.ilike.%${searchTerm}%,issue.ilike.%${searchTerm}%,imei.ilike.%${searchTerm}%`)
      .order('created_at', { ascending: false });
    
    return this.performQuery(query, 'searching');
  }

  async create(repairData: CreateRepairData): Promise<Repair> {
    console.log('Creating repair:', repairData);
    
    // Calculate total cost
    const partsTotal = repairData.repair_parts?.reduce((sum, part) => 
      sum + (part.unit_cost * part.quantity), 0
    ) || 0;
    
    const totalCost = (repairData.labor_cost || 0) + partsTotal;
    
    // Create the repair
    const { data: repair, error: repairError } = await this.supabase
      .from(this.tableName as any)
      .insert({
        client_id: repairData.client_id,
        technician_id: repairData.technician_id,
        device: repairData.device,
        imei: repairData.imei,
        issue: repairData.issue,
        status: repairData.status || 'quoted',
        priority: repairData.priority || 'normal',
        cost: totalCost,
        parts_cost: partsTotal,
        labor_cost: repairData.labor_cost || 0,
        estimated_completion_date: repairData.estimated_completion_date,
        notes: repairData.notes,
        repair_number: '' // Auto-generated by trigger
      })
      .select('*')
      .single();
    
    if (repairError) {
      this.handleError('creating', repairError);
    }
    
    if (!repair) {
      throw new Error('Failed to create repair');
    }
    
    // Create repair parts if any
    if (repairData.repair_parts && repairData.repair_parts.length > 0) {
      const repairParts = repairData.repair_parts.map(part => ({
        repair_id: (repair as any).id,
        product_id: part.product_id,
        quantity: part.quantity,
        unit_cost: part.unit_cost,
        total_cost: part.unit_cost * part.quantity
      }));
      
      const { error: partsError } = await this.supabase
        .from('repair_parts')
        .insert(repairParts);
      
      if (partsError) {
        // Cleanup: delete the repair if parts creation fails
        await this.supabase.from(this.tableName as any).delete().eq('id', (repair as any).id);
        this.handleError('creating repair parts', partsError);
      }
    }
    
    console.log('Repair created successfully:', repair);
    return repair as unknown as Repair;
  }

  async getTechnicians() {
    console.log('Fetching technicians...');
    
    const { data, error } = await this.supabase
      .from('profiles')
      .select('id, username')
      .order('username');
    
    if (error) {
      this.handleError('fetching technicians', error);
    }
    
    return data || [];
  }
}