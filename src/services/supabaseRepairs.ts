
import { supabase } from "@/integrations/supabase/client";

export type Repair = {
  id: string;
  repair_number: string;
  client_id?: string;
  technician_id?: string;
  device: string;
  imei?: string;
  issue: string;
  status: 'quoted' | 'in_progress' | 'awaiting_parts' | 'completed' | 'cancelled';
  priority: 'low' | 'normal' | 'high' | 'urgent';
  cost: number;
  parts_cost: number;
  labor_cost: number;
  estimated_completion_date?: string;
  actual_completion_date?: string;
  notes?: string;
  created_at?: string;
  updated_at?: string;
  client?: {
    id: string;
    type: string;
    first_name?: string;
    last_name?: string;
    company_name?: string;
    email?: string;
    phone?: string;
  };
  technician?: {
    id: string;
    username?: string;
  };
  repair_parts?: RepairPart[];
};

export type RepairPart = {
  id: string;
  repair_id: string;
  product_id: string;
  quantity: number;
  unit_cost: number;
  total_cost: number;
  product?: {
    id: string;
    name: string;
  };
};

export type CreateRepairData = {
  client_id?: string;
  technician_id?: string;
  device: string;
  imei?: string;
  issue: string;
  status?: 'quoted' | 'in_progress' | 'awaiting_parts' | 'completed' | 'cancelled';
  priority?: 'low' | 'normal' | 'high' | 'urgent';
  cost?: number;
  parts_cost?: number;
  labor_cost?: number;
  estimated_completion_date?: string;
  notes?: string;
  repair_parts?: {
    product_id: string;
    quantity: number;
    unit_cost: number;
  }[];
};

export const supabaseRepairsApi = {
  async getRepairs(searchTerm: string = '') {
    console.log('Fetching repairs from Supabase...');
    
    let query = supabase
      .from('repairs')
      .select(`
        *,
        client:clients(id, type, first_name, last_name, company_name, email, phone),
        technician:profiles(id, username),
        repair_parts(
          id,
          product_id,
          quantity,
          unit_cost,
          total_cost,
          product:products(id, name)
        )
      `);
    
    if (searchTerm) {
      query = query.or(`repair_number.ilike.%${searchTerm}%,device.ilike.%${searchTerm}%,issue.ilike.%${searchTerm}%,imei.ilike.%${searchTerm}%`);
    }
    
    const { data, error } = await query.order('created_at', { ascending: false });
    
    if (error) {
      console.error('Error fetching repairs:', error);
      throw error;
    }
    
    console.log('Repairs fetched successfully:', data);
    return data || [];
  },

  async getRepair(id: string) {
    console.log('Fetching repair:', id);
    
    const { data, error } = await supabase
      .from('repairs')
      .select(`
        *,
        client:clients(id, type, first_name, last_name, company_name, email, phone),
        technician:profiles(id, username),
        repair_parts(
          id,
          product_id,
          quantity,
          unit_cost,
          total_cost,
          product:products(id, name)
        )
      `)
      .eq('id', id)
      .single();
    
    if (error) {
      console.error('Error fetching repair:', error);
      throw error;
    }
    
    return data;
  },

  async createRepair(repairData: CreateRepairData) {
    console.log('Creating repair:', repairData);
    
    // Calculate total cost
    const partsTotal = repairData.repair_parts?.reduce((sum, part) => 
      sum + (part.unit_cost * part.quantity), 0
    ) || 0;
    
    const totalCost = (repairData.labor_cost || 0) + partsTotal;
    
    // Create the repair
    const { data: repair, error: repairError } = await supabase
      .from('repairs')
      .insert({
        client_id: repairData.client_id,
        technician_id: repairData.technician_id,
        device: repairData.device,
        imei: repairData.imei,
        issue: repairData.issue,
        status: repairData.status || 'quoted',
        priority: repairData.priority || 'normal',
        cost: totalCost,
        parts_cost: partsTotal,
        labor_cost: repairData.labor_cost || 0,
        estimated_completion_date: repairData.estimated_completion_date,
        notes: repairData.notes,
        repair_number: '' // Will be auto-generated by trigger
      })
      .select('*')
      .single();
    
    if (repairError) {
      console.error('Error creating repair:', repairError);
      throw repairError;
    }
    
    // Create repair parts if any
    if (repairData.repair_parts && repairData.repair_parts.length > 0) {
      const repairParts = repairData.repair_parts.map(part => ({
        repair_id: repair.id,
        product_id: part.product_id,
        quantity: part.quantity,
        unit_cost: part.unit_cost,
        total_cost: part.unit_cost * part.quantity
      }));
      
      const { error: partsError } = await supabase
        .from('repair_parts')
        .insert(repairParts);
      
      if (partsError) {
        console.error('Error creating repair parts:', partsError);
        throw partsError;
      }
    }
    
    console.log('Repair created successfully:', repair);
    return repair;
  },

  async updateRepair(id: string, repairData: Partial<CreateRepairData>) {
    console.log('Updating repair:', id, repairData);
    
    const { data, error } = await supabase
      .from('repairs')
      .update(repairData)
      .eq('id', id)
      .select('*')
      .single();
    
    if (error) {
      console.error('Error updating repair:', error);
      throw error;
    }
    
    console.log('Repair updated successfully:', data);
    return data;
  },

  async deleteRepair(id: string) {
    console.log('Deleting repair:', id);
    
    const { error } = await supabase
      .from('repairs')
      .delete()
      .eq('id', id);
    
    if (error) {
      console.error('Error deleting repair:', error);
      throw error;
    }
    
    console.log('Repair deleted successfully');
    return true;
  },

  async getTechnicians() {
    console.log('Fetching technicians...');
    
    const { data, error } = await supabase
      .from('profiles')
      .select('id, username')
      .order('username');
    
    if (error) {
      console.error('Error fetching technicians:', error);
      throw error;
    }
    
    return data || [];
  }
};
