import { BaseApiService } from '../core/BaseApiService';
import type { Sale, CreateSaleData } from './types';
import { SalesValidationService } from '../../components/sales/SalesValidationService';
import { useSalesMonitoring } from '../../components/sales/SalesMonitoringService';

export class SalesApiService extends BaseApiService<Sale, CreateSaleData> {
  constructor() {
    super('sales', `
      *,
      client:clients(id, type, first_name, last_name, company_name, email, phone),
      salesperson:profiles(id, username),
      sale_items(
        id,
        product_id,
        quantity,
        unit_price,
        total_price,
        serial_number,
        product:products(id, brand, model, year)
      )
    `);
  }

  async search(searchTerm: string): Promise<Sale[]> {
    if (!searchTerm.trim()) return this.getAll();
    
    console.log('Searching sales with term:', searchTerm);
    
    const searchPattern = `%${searchTerm.trim()}%`;
    
    // Search in sale_number, notes, and client information
    const query = this.supabase
      .from(this.tableName as any)
      .select(this.selectQuery)
      .or(`sale_number.ilike.${searchPattern},notes.ilike.${searchPattern},client.first_name.ilike.${searchPattern},client.last_name.ilike.${searchPattern},client.company_name.ilike.${searchPattern}`)
      .order('created_at', { ascending: false });
    
    return this.performQuery(query, 'searching');
  }

  async create(saleData: CreateSaleData): Promise<Sale> {
    console.log('Creating sale:', saleData);
    
    // Enhanced validation with security checks
    const validation = await SalesValidationService.validateSaleData(saleData);
    if (!validation.isValid) {
      throw new Error(`Dati non validi: ${validation.errors.join(', ')}`);
    }
    
    // Sanitize input data
    const sanitizedData = SalesValidationService.sanitizeInput(saleData);
    
    // Validate stock availability first
    const productItems = saleData.sale_items.map(item => ({
      product_id: item.product_id,
      quantity: item.quantity
    }));
    
    console.log('Validating stock for items:', productItems);
    const { error: stockError } = await this.supabase.rpc('validate_product_stock', {
      product_items: productItems
    });
    
    if (stockError) {
      console.error('Stock validation error:', stockError);
      throw new Error(stockError.message || 'Insufficient stock for one or more products');
    }
    
    console.log('Stock validation passed');
    
    // Validate serial numbers belong to their respective products
    const saleItemsForValidation = saleData.sale_items.map(item => ({
      product_id: item.product_id,
      serial_number: item.serial_number
    }));
    
    console.log('Validating serial numbers for items:', saleItemsForValidation);
    const { error: serialError } = await this.supabase.rpc('validate_sale_serial_numbers', {
      sale_items_data: saleItemsForValidation
    });
    
    if (serialError) {
      console.error('Serial number validation error:', serialError);
      throw new Error(serialError.message || 'One or more serial numbers do not belong to the selected products');
    }
    
    console.log('Serial number validation passed');
    
    // Calculate totals
    const subtotal = saleData.sale_items.reduce((sum, item) => 
      sum + (item.unit_price * item.quantity), 0
    );
    const tax_amount = subtotal * 0.1; // 10% tax
    const total_amount = subtotal + tax_amount;
    
    console.log('Calculated totals:', { subtotal, tax_amount, total_amount });
    
    // Create the sale - let database generate sale_number via trigger
    console.log('Inserting sale record...');
    const { data: sale, error: saleError } = await this.supabase
      .from(this.tableName as any)
      .insert({
        client_id: saleData.client_id,
        salesperson_id: saleData.salesperson_id,
        status: saleData.status || 'completed',
        payment_method: saleData.payment_method,
        subtotal,
        tax_amount,
        total_amount,
        notes: saleData.notes
        // sale_number will be auto-generated by database trigger
      })
      .select(this.selectQuery)
      .single();
    
    if (saleError) {
      console.error('Sale creation error:', saleError);
      this.handleError('creating', saleError);
    }
    
    console.log('Sale created successfully:', sale);
    
    if (!sale) {
      throw new Error('Failed to create sale');
    }
    
    // Create sale items
    const saleItems = saleData.sale_items.map(item => ({
      sale_id: (sale as any).id,
      product_id: item.product_id,
      quantity: item.quantity,
      unit_price: item.unit_price,
      total_price: item.unit_price * item.quantity,
      serial_number: item.serial_number
    }));
    
    const { error: itemsError } = await this.supabase
      .from('sale_items')
      .insert(saleItems);
    
    if (itemsError) {
      // Cleanup: delete the sale if items creation fails
      await this.supabase.from(this.tableName as any).delete().eq('id', (sale as any).id);
      this.handleError('creating sale items', itemsError);
    }
    
    // Fetch complete sale with items
    const completeSale = await this.getById((sale as any).id);
    console.log('Sale created successfully:', completeSale);
    return completeSale;
  }

  async update(id: string, saleData: Partial<CreateSaleData>): Promise<Sale> {
    console.log('Updating sale:', id, saleData);
    
    // Handle sale items updates if provided
    if (saleData.sale_items) {
      // Validate stock for new quantities
      const productItems = saleData.sale_items.map(item => ({
        product_id: item.product_id,
        quantity: item.quantity
      }));
      
      const { error: stockError } = await this.supabase.rpc('validate_product_stock', {
        product_items: productItems
      });
      
      if (stockError) {
        throw new Error(stockError.message || 'Insufficient stock for one or more products');
      }
      
      // Validate serial numbers belong to their respective products
      const saleItemsForValidation = saleData.sale_items.map(item => ({
        product_id: item.product_id,
        serial_number: item.serial_number
      }));
      
      const { error: serialError } = await this.supabase.rpc('validate_sale_serial_numbers', {
        sale_items_data: saleItemsForValidation
      });
      
      if (serialError) {
        throw new Error(serialError.message || 'One or more serial numbers do not belong to the selected products');
      }
      
      // Delete existing sale items (restores stock via trigger)
      const { error: deleteError } = await this.supabase
        .from('sale_items')
        .delete()
        .eq('sale_id', id);
      
      if (deleteError) {
        this.handleError('deleting old sale items', deleteError);
      }
      
      // Create new sale items
      const saleItems = saleData.sale_items.map(item => ({
        sale_id: id,
        product_id: item.product_id,
        quantity: item.quantity,
        unit_price: item.unit_price,
        total_price: item.unit_price * item.quantity,
        serial_number: item.serial_number
      }));
      
      const { error: itemsError } = await this.supabase
        .from('sale_items')
        .insert(saleItems);
      
      if (itemsError) {
        this.handleError('creating new sale items', itemsError);
      }
      
      // Recalculate totals
      const subtotal = saleData.sale_items.reduce((sum, item) => 
        sum + (item.unit_price * item.quantity), 0
      );
      const tax_amount = subtotal * 0.1;
      const total_amount = subtotal + tax_amount;
      
      // Update sale with new totals
      const updateData = {
        ...saleData,
        subtotal,
        tax_amount,
        total_amount,
        sale_items: undefined // Remove from update object
      };
      
      return super.update(id, updateData as Partial<CreateSaleData>);
    }
    
    // Simple update without item changes
    return super.update(id, saleData);
  }


  async delete(id: string): Promise<boolean> {
    console.log('Deleting sale:', id);
    
    // Delete sale items first (restores stock via trigger)
    const { error: itemsError } = await this.supabase
      .from('sale_items')
      .delete()
      .eq('sale_id', id);
    
    if (itemsError) {
      this.handleError('deleting sale items', itemsError);
    }
    
    // Delete the sale
    return super.delete(id);
  }
}