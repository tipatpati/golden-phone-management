import { supabase } from "@/integrations/supabase/client";
import type { CreateSaleData } from "./types";

export const supabaseSalesApi = {
  async getSales(searchTerm: string = '') {
    console.log('Fetching sales from Supabase...');
    
    let query = supabase
      .from('sales')
      .select(`
        *,
        client:clients(id, type, first_name, last_name, company_name, email, phone),
        salesperson:profiles(id, username),
        sale_items(
          id,
          product_id,
          quantity,
          unit_price,
          total_price,
          serial_number,
          product:products(id, brand, model, year)
        )
      `);
    
    if (searchTerm) {
      // Use individual filters instead of .or() to avoid ambiguity
      query = query.or(`sale_number.ilike.%${searchTerm}%,notes.ilike.%${searchTerm}%`);
    }
    
    const { data, error } = await query.order('created_at', { ascending: false });
    
    if (error) {
      console.error('Error fetching sales:', error);
      throw error;
    }
    
    console.log('Sales fetched successfully:', data);
    return data || [];
  },

  async getSale(id: string) {
    console.log('Fetching sale:', id);
    
    const { data, error } = await supabase
      .from('sales')
      .select(`
        *,
        client:clients(id, type, first_name, last_name, company_name, email, phone),
        salesperson:profiles(id, username),
        sale_items(
          id,
          product_id,
          quantity,
          unit_price,
          total_price,
          serial_number,
          product:products(id, brand, model, year)
        )
      `)
      .eq('id', id)
      .single();
    
    if (error) {
      console.error('Error fetching sale:', error);
      throw error;
    }
    
    return data;
  },

  async createSale(saleData: CreateSaleData) {
    console.log('Creating sale:', saleData);
    
    // Validate stock availability first
    const productItems = saleData.sale_items.map(item => ({
      product_id: item.product_id,
      quantity: item.quantity
    }));
    
    const { error: stockError } = await supabase.rpc('validate_product_stock', {
      product_items: productItems
    });
    
    if (stockError) {
      console.error('Stock validation error:', stockError);
      throw new Error(stockError.message || 'Insufficient stock for one or more products');
    }
    
    // Calculate totals
    const subtotal = saleData.sale_items.reduce((sum, item) => 
      sum + (item.unit_price * item.quantity), 0
    );
    const tax_amount = subtotal * 0.1; // 10% tax
    const total_amount = subtotal + tax_amount;
    
    // Create the sale - provide empty sale_number that will be overridden by trigger
    const { data: sale, error: saleError } = await supabase
      .from('sales')
      .insert({
        client_id: saleData.client_id,
        salesperson_id: saleData.salesperson_id,
        status: saleData.status || 'completed',
        payment_method: saleData.payment_method,
        subtotal,
        tax_amount,
        total_amount,
        notes: saleData.notes,
        sale_number: '' // Placeholder - will be auto-generated by the trigger
      })
      .select(`
        *,
        client:clients(id, type, first_name, last_name, company_name, email, phone),
        salesperson:profiles(id, username)
      `)
      .single();
    
    if (saleError) {
      console.error('Error creating sale:', saleError);
      throw saleError;
    }
    
    // Create sale items - this will automatically update stock via trigger
    const saleItems = saleData.sale_items.map(item => ({
      sale_id: sale.id,
      product_id: item.product_id,
      quantity: item.quantity,
      unit_price: item.unit_price,
      total_price: item.unit_price * item.quantity,
      serial_number: item.serial_number
    }));
    
    const { error: itemsError } = await supabase
      .from('sale_items')
      .insert(saleItems);
    
    if (itemsError) {
      console.error('Error creating sale items:', itemsError);
      // If sale items fail, we should delete the sale to maintain consistency
      await supabase.from('sales').delete().eq('id', sale.id);
      throw itemsError;
    }
    
    // Fetch the complete sale with items for receipt
    const { data: completeSale, error: fetchError } = await supabase
      .from('sales')
      .select(`
        *,
        client:clients(id, type, first_name, last_name, company_name, email, phone),
        salesperson:profiles(id, username),
        sale_items(
          id,
          product_id,
          quantity,
          unit_price,
          total_price,
          serial_number,
          product:products(id, brand, model, year)
        )
      `)
      .eq('id', sale.id)
      .single();
    
    if (fetchError) {
      console.error('Error fetching complete sale:', fetchError);
      // Return basic sale if fetch fails
      return sale;
    }
    
    console.log('Sale created successfully with stock updates:', completeSale);
    return completeSale;
  },

  async updateSale(id: string, saleData: Partial<CreateSaleData>) {
    console.log('Updating sale:', id, saleData);
    
    // If sale items are being updated, we need to handle stock changes
    if (saleData.sale_items) {
      // Validate stock for new quantities
      const productItems = saleData.sale_items.map(item => ({
        product_id: item.product_id,
        quantity: item.quantity
      }));
      
      const { error: stockError } = await supabase.rpc('validate_product_stock', {
        product_items: productItems
      });
      
      if (stockError) {
        console.error('Stock validation error:', stockError);
        throw new Error(stockError.message || 'Insufficient stock for one or more products');
      }
      
      // Delete existing sale items (this will restore stock via trigger)
      const { error: deleteError } = await supabase
        .from('sale_items')
        .delete()
        .eq('sale_id', id);
      
      if (deleteError) {
        console.error('Error deleting old sale items:', deleteError);
        throw deleteError;
      }
      
      // Create new sale items (this will update stock via trigger)
      const saleItems = saleData.sale_items.map(item => ({
        sale_id: id,
        product_id: item.product_id,
        quantity: item.quantity,
        unit_price: item.unit_price,
        total_price: item.unit_price * item.quantity,
        serial_number: item.serial_number
      }));
      
      const { error: itemsError } = await supabase
        .from('sale_items')
        .insert(saleItems);
      
      if (itemsError) {
        console.error('Error creating new sale items:', itemsError);
        throw itemsError;
      }
      
      // Recalculate totals
      const subtotal = saleData.sale_items.reduce((sum, item) => 
        sum + (item.unit_price * item.quantity), 0
      );
      const tax_amount = subtotal * 0.1;
      const total_amount = subtotal + tax_amount;
      
      // Update sale with new totals
      const { data, error } = await supabase
        .from('sales')
        .update({
          ...saleData,
          subtotal,
          tax_amount,
          total_amount,
          sale_items: undefined // Remove sale_items from update object
        })
        .eq('id', id)
        .select('*')
        .single();
      
      if (error) {
        console.error('Error updating sale:', error);
        throw error;
      }
      
      console.log('Sale updated successfully with stock changes:', data);
      return data;
    } else {
      // Simple update without item changes
      const { data, error } = await supabase
        .from('sales')
        .update(saleData)
        .eq('id', id)
        .select('*')
        .single();
      
      if (error) {
        console.error('Error updating sale:', error);
        throw error;
      }
      
      console.log('Sale updated successfully:', data);
      return data;
    }
  },

  async deleteSale(id: string) {
    console.log('Deleting sale:', id);
    
    // Delete sale items first (this will restore stock via trigger)
    const { error: itemsError } = await supabase
      .from('sale_items')
      .delete()
      .eq('sale_id', id);
    
    if (itemsError) {
      console.error('Error deleting sale items:', itemsError);
      throw itemsError;
    }
    
    // Delete the sale
    const { error } = await supabase
      .from('sales')
      .delete()
      .eq('id', id);
    
    if (error) {
      console.error('Error deleting sale:', error);
      throw error;
    }
    
    console.log('Sale deleted successfully with stock restoration');
    return true;
  }
};