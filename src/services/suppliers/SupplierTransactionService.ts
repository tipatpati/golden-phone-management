import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import type { 
  SupplierTransaction, 
  SupplierTransactionItem,
  CreateTransactionData,
  UpdateTransactionData,
  EditableTransactionItem,
  TransactionSearchFilters,
  TransactionSummary
} from './types';

// ============= QUERY KEYS =============
export const SUPPLIER_TRANSACTION_KEYS = {
  all: ['supplier-transactions'] as const,
  lists: () => [...SUPPLIER_TRANSACTION_KEYS.all, 'list'] as const,
  list: (filters: TransactionSearchFilters) => [...SUPPLIER_TRANSACTION_KEYS.lists(), filters] as const,
  details: () => [...SUPPLIER_TRANSACTION_KEYS.all, 'detail'] as const,
  detail: (id: string) => [...SUPPLIER_TRANSACTION_KEYS.details(), id] as const,
  items: (transactionId: string) => [...SUPPLIER_TRANSACTION_KEYS.all, 'items', transactionId] as const,
  summary: () => [...SUPPLIER_TRANSACTION_KEYS.all, 'summary'] as const,
};

// ============= API FUNCTIONS =============
export const supplierTransactionApi = {
  async getAll(filters: TransactionSearchFilters = {}): Promise<SupplierTransaction[]> {
    let query = (supabase as any)
      .from("supplier_transactions")
      .select(`
        *,
        suppliers (
          name
        )
      `)
      .order("transaction_date", { ascending: false });

    // Apply filters
    if (filters.searchTerm) {
      query = query.or(`transaction_number.ilike.%${filters.searchTerm}%,suppliers.name.ilike.%${filters.searchTerm}%`);
    }
    if (filters.type && filters.type !== 'all') {
      query = query.eq('type', filters.type);
    }
    if (filters.status && filters.status !== 'all') {
      query = query.eq('status', filters.status);
    }
    if (filters.supplier_id) {
      query = query.eq('supplier_id', filters.supplier_id);
    }
    if (filters.dateFrom) {
      query = query.gte('transaction_date', filters.dateFrom);
    }
    if (filters.dateTo) {
      query = query.lte('transaction_date', filters.dateTo);
    }

    const { data, error } = await query;
    if (error) throw error;
    return data as SupplierTransaction[];
  },

  async getById(id: string): Promise<SupplierTransaction> {
    const { data, error } = await (supabase as any)
      .from("supplier_transactions")
      .select(`
        *,
        suppliers (
          name
        )
      `)
      .eq('id', id)
      .single();
    
    if (error) throw error;
    return data as SupplierTransaction;
  },

  async create(transactionData: CreateTransactionData): Promise<SupplierTransaction> {
    // Start transaction - transaction_number is auto-generated by database
    const { data: transaction, error: transactionError } = await (supabase as any)
      .from("supplier_transactions")
      .insert({
        supplier_id: transactionData.supplier_id,
        type: transactionData.type,
        total_amount: transactionData.total_amount,
        transaction_date: transactionData.transaction_date,
        notes: transactionData.notes,
        status: transactionData.status || "pending",
      })
      .select()
      .single();

    if (transactionError) throw transactionError;

    // Create transaction items
    if (transactionData.items.length > 0) {
      const transactionItems = transactionData.items.map(item => ({
        transaction_id: transaction.id,
        product_id: item.product_id,
        quantity: item.quantity,
        unit_cost: item.unit_cost,
        total_cost: item.quantity * item.unit_cost,
        unit_details: item.unit_barcodes?.length ? { barcodes: item.unit_barcodes } : {},
      }));

      const { error: itemsError } = await (supabase as any)
        .from("supplier_transaction_items")
        .insert(transactionItems);

      if (itemsError) {
        // Rollback transaction if items creation fails
        await (supabase as any).from("supplier_transactions").delete().eq("id", transaction.id);
        throw itemsError;
      }
    }

    return transaction as SupplierTransaction;
  },

  async update(id: string, updates: UpdateTransactionData): Promise<void> {
    const { error } = await (supabase as any)
      .from("supplier_transactions")
      .update(updates)
      .eq("id", id);
    
    if (error) throw error;
  },

  async delete(id: string): Promise<void> {
    const { error } = await (supabase as any)
      .from("supplier_transactions")
      .delete()
      .eq("id", id);
    
    if (error) throw error;
  },

  async getItems(transactionId: string): Promise<SupplierTransactionItem[]> {
    const { data, error } = await (supabase as any)
      .from("supplier_transaction_items")
      .select(`
        *,
        products (
          brand,
          model,
          has_serial
        )
      `)
      .eq("transaction_id", transactionId)
      .order("created_at", { ascending: true });
    
    if (error) throw error;
    return data as SupplierTransactionItem[];
  },

  async replaceItems(transactionId: string, items: EditableTransactionItem[]): Promise<void> {
    // Delete existing items
    const { error: deleteError } = await (supabase as any)
      .from("supplier_transaction_items")
      .delete()
      .eq("transaction_id", transactionId);
    
    if (deleteError) throw deleteError;

    // Insert new items if any
    if (items.length > 0) {
      const itemsToInsert = items.map(item => ({
        transaction_id: transactionId,
        product_id: item.product_id,
        quantity: item.quantity,
        unit_cost: item.unit_cost,
        total_cost: item.quantity * item.unit_cost,
        unit_details: item.unit_barcodes?.length ? { barcodes: item.unit_barcodes } : {},
      }));

      const { error: insertError } = await (supabase as any)
        .from("supplier_transaction_items")
        .insert(itemsToInsert);
      
      if (insertError) throw insertError;
    }
  },

  async getSummary(filters: TransactionSearchFilters = {}): Promise<TransactionSummary> {
    let query = (supabase as any)
      .from("supplier_transactions")
      .select("type, status, total_amount");

    // Apply same filters as getAll
    if (filters.supplier_id) {
      query = query.eq('supplier_id', filters.supplier_id);
    }
    if (filters.dateFrom) {
      query = query.gte('transaction_date', filters.dateFrom);
    }
    if (filters.dateTo) {
      query = query.lte('transaction_date', filters.dateTo);
    }

    const { data, error } = await query;
    if (error) throw error;

    // Calculate summary
    const summary: TransactionSummary = {
      total_transactions: data.length,
      total_amount: data.reduce((sum, t) => sum + t.total_amount, 0),
      pending_count: data.filter(t => t.status === 'pending').length,
      completed_count: data.filter(t => t.status === 'completed').length,
      cancelled_count: data.filter(t => t.status === 'cancelled').length,
      purchase_amount: data.filter(t => t.type === 'purchase').reduce((sum, t) => sum + t.total_amount, 0),
      payment_amount: data.filter(t => t.type === 'payment').reduce((sum, t) => sum + t.total_amount, 0),
      return_amount: data.filter(t => t.type === 'return').reduce((sum, t) => sum + t.total_amount, 0),
    };

    return summary;
  },
};

// ============= REACT QUERY HOOKS =============
export function useSupplierTransactions(filters: TransactionSearchFilters = {}) {
  return useQuery({
    queryKey: SUPPLIER_TRANSACTION_KEYS.list(filters),
    queryFn: () => supplierTransactionApi.getAll(filters),
    staleTime: 30000, // 30 seconds
  });
}

export function useSupplierTransaction(id: string) {
  return useQuery({
    queryKey: SUPPLIER_TRANSACTION_KEYS.detail(id),
    queryFn: () => supplierTransactionApi.getById(id),
    enabled: !!id,
  });
}

export function useSupplierTransactionItems(transactionId: string) {
  return useQuery({
    queryKey: SUPPLIER_TRANSACTION_KEYS.items(transactionId),
    queryFn: () => supplierTransactionApi.getItems(transactionId),
    enabled: !!transactionId,
  });
}

export function useTransactionSummary(filters: TransactionSearchFilters = {}) {
  return useQuery({
    queryKey: SUPPLIER_TRANSACTION_KEYS.summary(),
    queryFn: () => supplierTransactionApi.getSummary(filters),
  });
}

export function useCreateSupplierTransaction() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: supplierTransactionApi.create,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: SUPPLIER_TRANSACTION_KEYS.all });
    },
  });
}

export function useUpdateSupplierTransaction() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, updates }: { id: string; updates: UpdateTransactionData }) =>
      supplierTransactionApi.update(id, updates),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: SUPPLIER_TRANSACTION_KEYS.all });
    },
  });
}

export function useDeleteSupplierTransaction() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: supplierTransactionApi.delete,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: SUPPLIER_TRANSACTION_KEYS.all });
    },
  });
}

export function useReplaceSupplierTransactionItems() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ transactionId, items }: { transactionId: string; items: EditableTransactionItem[] }) =>
      supplierTransactionApi.replaceItems(transactionId, items),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: SUPPLIER_TRANSACTION_KEYS.all });
      queryClient.invalidateQueries({ queryKey: SUPPLIER_TRANSACTION_KEYS.items(variables.transactionId) });
    },
  });
}